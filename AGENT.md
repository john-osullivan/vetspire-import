- Always ask for my permission before making code changes, unless I explicitly state otherwise.
- Always prefer to reuse existing primitives rather than creating a new solution. Do extra research throughout the codebase to make sure you haven't missed any available code.
- Good code is easily maintainable by humans. This means that non-DRY structures like a long series of if statements, rather than looping through an array and expressing the logic once, should never be used. Prioritize human legibility and ergonomics over code that's convenient for LLMs.
- Failing fast makes systems more predictable, and predictable systems are more trustworthy. Good systems clearly communicate their behavior and then follow it precisely. If inputs mean behavior can't be followed, failing fast makes things predictable -- 100% functional or 0% functional, nothing in the middle.
- Using empty input values (eg "" for string) in contexts where key functionality depends on having them be meaningful is a form of silent degradation. Other functions will expect that value to always be accurately defined, and they will all eventually fail when they hit a placeholder. Faking functionality to cover an error will always produce more errors, so you should instead proactively
- Write basic E2E tests to evaluate whether the overall system is behaving. Isolated components which perform focused functions, like a `findClientMatch()` function which checks a set of existing records to see whether our current input has already been saved, can have narrower integration tests to prevent regressions. The goal is being able to easily check whether things are working by calling npm run test. I typically prefer to only use unit tests on logic that is blackboxed, complex, and has no side effects. If something fits that bill, then you can draft unit tests for that.
- All of my functionality should be triggerable from a terminal command, all outputs should be saved in the outputs directory and named such that they sort chronologically.
- Prefer DRY code which reuses more generic functions, even if repeating yourself would be more "explicit".
- Never use Typescript's `any`. Use unknown, parsers, and type guards to maintain type safety throughout runtime.
- Use a library to parse CLI arguments, something like yargs, to help keep the code well-organized. I like the following code organization concepts:
  - "commands" group the interface functions that my program exposes to callers
  - "services" group together the business logic code implementing this interface, generally encapsulating chunks of our system. For example, we might have one service which handles CSV operations.
  - "clients" group together "adapter" functions for our third parties, providing a cleaner interface for our business logic. I expect we'll have 2 clients, pdfClient & vetspireClient, and the vetspireClient will export helper functions like `getUserByEmail(email:string)`.
- When we've established a good threshold for working functionality, commit to git.
